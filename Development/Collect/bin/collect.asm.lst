------- FILE collect.asm LEVEL 1 PASS 2
      1  10000 ????						;===============================================================================
      2  10000 ????						; Program Information
      3  10000 ????						;===============================================================================
      4  10000 ????
      5  10000 ????						; Program:	 Collect
      6  10000 ????						; Program by:	 Darrell Spice, Jr
      7  10000 ????						; Last Update:  July 10, 2014
      8  10000 ????						;
      9  10000 ????						; Super simple game of "collect the boxes" used for presentation on
     10  10000 ????						; developing Atari 2600 homebrew games.
     11  10000 ????						;
     12  10000 ????						; See readme.txt for compile instructions
     13  10000 ????
     14  10000 ????
     15  10000 ????						;===============================================================================
     16  10000 ????						; Change Log
     17  10000 ????						;===============================================================================
     18  10000 ????
     19  10000 ????						; 2014.06.24 - generate a stable display
     20  10000 ????						; 2014.06.25 - add timers
     21  10000 ????						; 2014.06.28 - add score display and check for TV Type
     22  10000 ????						; 2014.07.03 - add 2LK (2 line kernel)
     23  10000 ????						; 2014.07.04 - 2LK update, set VDELP0 and VDELP1 based on Y positions
     24  10000 ????						; 2014.07.04a- swapped GRP0 and GRP1 lines in the 2LK.  That gives us a
     25  10000 ????						;		possiblity of adding the BALL object
     26  10000 ????						;	      - changed Score+1 to be a bar across the screen so we can have
     27  10000 ????						;		a 2 player option
     28  10000 ????						; 2014.07.06 - Draw the Arena, playfield collision logic
     29  10000 ????						; 2014.07.07 - Select/Reset Switches, game active/inactive logic
     30  10000 ????						; 2014.07.09 - Game Variations
     31  10000 ????						; 2014.07.10 - "Random" numbers, 1 player game now playable
     32  10000 ????
     33  10000 ????						;===============================================================================
     34  10000 ????						; Initialize dasm
     35  10000 ????						;===============================================================================
     36  10000 ????
     37  10000 ????						; Dasm supports a number of processors, this line tells dasm the code
     38  10000 ????						; is for the 6502 CPU.  The Atari has a 6507, which is 6502 that's been
     39  10000 ????						; put into a "reduced package".  This package limits the 6507 to an 8K
     40  10000 ????						; address space and also removes support for external interrupts.
     41  10000 ????				       PROCESSOR	6502
     42  10000 ????
     43  10000 ????						; vcs.h contains the standard definitions for TIA and RIOT registers
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	vcs.h
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at http://www.atari2600.org/dasm
     14  10000 ????						;
     15  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  10000 ????						; with your views.  Please contribute, if you think you can improve this
     19  10000 ????						; file!
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE collect.asm
     45  0000 ????
     46  0000 ????						; macro.h contains commonly used routines which aid in coding
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	macro.h
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.05, 13/NOVEMBER/2003
      3  0000 ????
      4  0000 ????	       00 69	   VERSION_MACRO =	105
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     22  0000 ????						;			    This will allow conditional code to verify MACRO.H being
     23  0000 ????						;			    used for code assembly.
     24  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     25  0000 ????						;
     26  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     27  0000 ????						;
     28  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     29  0000 ????						;			   (standardised macro for vertical synch code)
     30  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     31  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     32  0000 ????						; 1.0	22/MAR/2003		Initial release
     33  0000 ????
     34  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     35  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     36  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     37  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     38  0000 ????						;   registers and require them to be defined first).
     39  0000 ????
     40  0000 ????						; Available macros...
     41  0000 ????						;   SLEEP n		 - sleep for n cycles
     42  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     43  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     44  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     45  0000 ????
     46  0000 ????						;-------------------------------------------------------------------------------
     47  0000 ????						; SLEEP duration
     48  0000 ????						; Original author: Thomas Jentzsch
     49  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     50  0000 ????						; useful for code where precise timing is required.
     51  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     52  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     53  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     54  0000 ????
     55  0000 ????				      MAC	sleep
     56  0000 ????			   .CYCLES    SET	{1}
     57  0000 ????
     58  0000 ????				      IF	.CYCLES < 2
     59  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     60  0000 ????				      ERR
     61  0000 ????				      ENDIF
     62  0000 ????
     63  0000 ????				      IF	.CYCLES & 1
     64  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     65  0000 ????				      nop	0
     66  0000 ????				      ELSE
     67  0000 ????				      bit	VSYNC
     68  0000 ????				      ENDIF
     69  0000 ????			   .CYCLES    SET	.CYCLES - 3
     70  0000 ????				      ENDIF
     71  0000 ????
     72  0000 ????				      REPEAT	.CYCLES / 2
     73  0000 ????				      nop
     74  0000 ????				      REPEND
     75  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     76  0000 ????
     77  0000 ????						;-------------------------------------------------------------------------------
     78  0000 ????						; VERTICAL_SYNC
     79  0000 ????						; Original author: Manuel Polik
     80  0000 ????						; Inserts the code required for a proper 3 scannline 
     81  0000 ????						; vertical sync sequence
     82  0000 ????						;
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????						;
     85  0000 ????						; IN:
     86  0000 ????						; OUT: A = 1
     87  0000 ????
     88  0000 ????				      MAC	vertical_sync
     89  0000 ????				      LDA	#$02	; A = VSYNC enable
     90  0000 ????				      STA	WSYNC	; Finish current line
     91  0000 ????				      STA	VSYNC	; Start vertical sync
     92  0000 ????				      STA	WSYNC	; 1st line vertical sync
     93  0000 ????				      STA	WSYNC	; 2nd line vertical sync
     94  0000 ????				      LSR		; A = VSYNC disable
     95  0000 ????				      STA	WSYNC	; 3rd line vertical sync
     96  0000 ????				      STA	VSYNC	; Stop vertical sync
     97  0000 ????				      ENDM
     98  0000 ????
     99  0000 ????						;-------------------------------------------------------------------------------
    100  0000 ????						; CLEAN_START
    101  0000 ????						; Original author: Andrew Davie
    102  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    103  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    104  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    105  0000 ????						; Use as very first section of code on boot (ie: at reset)
    106  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    107  0000 ????
    108  0000 ????				      MAC	clean_start
    109  0000 ????				      sei
    110  0000 ????				      cld
    111  0000 ????
    112  0000 ????				      ldx	#0
    113  0000 ????				      txa
    114  0000 ????				      tay
    115  0000 ????			   .CLEAR_STACK dex
    116  0000 ????				      txs
    117  0000 ????				      pha
    118  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    119  0000 ????
    120  0000 ????				      ENDM
    121  0000 ????
    122  0000 ????						;-------------------------------------------------------
    123  0000 ????						; SET_POINTER
    124  0000 ????						; Original author: Manuel Rotschkar
    125  0000 ????						;
    126  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    127  0000 ????						;
    128  0000 ????						; Usage: SET_POINTER pointer, address
    129  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    130  0000 ????						;
    131  0000 ????						; Note: Alters the accumulator, NZ flags
    132  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    133  0000 ????						; IN 2: absolute address
    134  0000 ????
    135  0000 ????				      MAC	set_pointer
    136  0000 ????			   .POINTER   SET	{1}
    137  0000 ????			   .ADDRESS   SET	{2}
    138  0000 ????
    139  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    140  0000 ????				      STA	.POINTER	; Store in pointer
    141  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    142  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    143  0000 ????
    144  0000 ????				      ENDM
    145  0000 ????
    146  0000 ????
    147  0000 ????						;-------------------------------------------------------
    148  0000 ????						; SAME PAGE BRANCH CHECK
    149  0000 ????						; Original auther: John Payson
    150  0000 ????						;
    151  0000 ????						; Usage: sbeq, sbne, etc just like a normal beq, bne, etc.
    152  0000 ????						;	  A message will be output if the target of the branch
    153  0000 ????						;	  is not on the same page.
    154  0000 ????						;
    155  0000 ????				      mac	sbcc
    156  0000 ????				      bcc	{1}
    157  0000 ????				      if	(* ^ {1}) & $FF00
    158  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    159  0000 ????				      err
    160  0000 ????				      endif
    161  0000 ????				      endm
    162  0000 ????
    163  0000 ????				      mac	sbcs
    164  0000 ????				      bcs	{1}
    165  0000 ????				      if	(* ^ {1}) & $FF00
    166  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    167  0000 ????				      err
    168  0000 ????				      endif
    169  0000 ????				      endm
    170  0000 ????
    171  0000 ????				      mac	sbeq
    172  0000 ????				      beq	{1}
    173  0000 ????				      if	(* ^ {1}) & $FF00
    174  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    175  0000 ????				      err
    176  0000 ????				      endif
    177  0000 ????				      endm
    178  0000 ????
    179  0000 ????				      mac	sbmi
    180  0000 ????				      bmi	{1}
    181  0000 ????				      if	(* ^ {1}) & $FF00
    182  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    183  0000 ????				      err
    184  0000 ????				      endif
    185  0000 ????				      endm
    186  0000 ????
    187  0000 ????				      mac	sbne
    188  0000 ????				      bne	{1}
    189  0000 ????				      if	(* ^ {1}) & $FF00
    190  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    191  0000 ????				      err
    192  0000 ????				      endif
    193  0000 ????				      endm
    194  0000 ????
    195  0000 ????				      mac	sbpl
    196  0000 ????				      bpl	{1}
    197  0000 ????				      if	(* ^ {1}) & $FF00
    198  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    199  0000 ????				      err
    200  0000 ????				      endif
    201  0000 ????				      endm
    202  0000 ????
    203  0000 ????				      mac	sbvc
    204  0000 ????				      bvc	{1}
    205  0000 ????				      if	(* ^ {1}) & $FF00
    206  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    207  0000 ????				      err
    208  0000 ????				      endif
    209  0000 ????				      endm
    210  0000 ????
    211  0000 ????				      mac	sbvs
    212  0000 ????				      bvs	{1}
    213  0000 ????				      if	(* ^ {1}) & $FF00
    214  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    215  0000 ????				      err
    216  0000 ????				      endif
    217  0000 ????				      endm
    218  0000 ????
    219  0000 ????						;-------------------------------------------------------
    220  0000 ????						; DIFFERENT PAGE BRANCH CHECK
    221  0000 ????						; Original auther: Darrell Spice, Jr.
    222  0000 ????						;
    223  0000 ????						; Usage: dbeq, dbne, etc just like a normal beq, bne, etc.
    224  0000 ????						;	  A message will be output if the target of the branch
    225  0000 ????						;	  is not on a different page.
    226  0000 ????						;
    227  0000 ????				      mac	dbcc
    228  0000 ????				      bcc	{1}
    229  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    230  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    231  0000 ????				      err
    232  0000 ????				      endif
    233  0000 ????				      endm
    234  0000 ????
    235  0000 ????				      mac	dbcs
    236  0000 ????				      bcs	{1}
    237  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    238  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    239  0000 ????				      err
    240  0000 ????				      endif
    241  0000 ????				      endm
    242  0000 ????
    243  0000 ????				      mac	dbeq
    244  0000 ????				      beq	{1}
    245  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    246  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    247  0000 ????				      err
    248  0000 ????				      endif
    249  0000 ????				      endm
    250  0000 ????
    251  0000 ????				      mac	dbmi
    252  0000 ????				      bmi	{1}
    253  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    254  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    255  0000 ????				      err
    256  0000 ????				      endif
    257  0000 ????				      endm
    258  0000 ????
    259  0000 ????				      mac	dbne
    260  0000 ????				      bne	{1}
    261  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    262  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    263  0000 ????				      err
    264  0000 ????				      endif
    265  0000 ????				      endm
    266  0000 ????
    267  0000 ????				      mac	dbpl
    268  0000 ????				      bpl	{1}
    269  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    270  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    271  0000 ????				      err
    272  0000 ????				      endif
    273  0000 ????				      endm
    274  0000 ????
    275  0000 ????				      mac	dbvc
    276  0000 ????				      bvc	{1}
    277  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    278  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    279  0000 ????				      err
    280  0000 ????				      endif
    281  0000 ????				      endm
    282  0000 ????
    283  0000 ????				      mac	dbvs
    284  0000 ????				      bvs	{1}
    285  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    286  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    287  0000 ????				      err
    288  0000 ????				      endif
    289  0000 ????				      endm
    290  0000 ????
    291  0000 ????						; EOF 
    292  0000 ????
    293  0000 ????
------- FILE collect.asm
     48  0000 ????
     49  0000 ????						;===============================================================================
     50  0000 ????						; Define Constants
     51  0000 ????						;===============================================================================
     52  0000 ????						; height of the arena (gameplay area).  Since we're using a 2 line kernel,
     53  0000 ????						; actual height will be twice this.  Also, we're using 0-87 for the
     54  0000 ????						; scanlines so actual height is 176 = 88*2
     55  0000 ????	       00 57	   ARENA_HEIGHT =	87
     56  0000 ????
     57  0000 ????						;===============================================================================
     58  0000 ????						; Define RAM Usage
     59  0000 ????						;===============================================================================
     60  0000 ????
     61  0000 ????						; define a segment for variables
     62  0000 ????						; .U means uninitialized, does not end up in ROM
     63 U00ad ????				      SEG.U	VARS
     64 U00ad ????
     65 U00ad ????						; RAM starts at $80
     66 U0080					      ORG	$80
     67 U0080
     68 U0080							; Holds 2 digit score for each player, stored as BCD (Binary Coded Decimal)
     69 U0080		       00 00	   Score      ds	2	; stored in $80-81
     70 U0082							; CODING TIP - The : is optional. However, if you remember to include the :
     71 U0082							;		in all of your labels you can then easily find where
     72 U0082							;		something is defined by including : in the search.
     73 U0082							;		Find "Score:" will bring you here, find "Score" will locate
     74 U0082							;		all places that the variable Score is used.
     75 U0082
     76 U0082							; Offsets into digit graphic data
     77 U0082		       00 00	   DigitOnes  ds	2	; stored in $82-83, DigitOnes = Score, DigitOnes+1 = Score+1
     78 U0084		       00 00	   DigitTens  ds	2	; stored in $84-85, DigitTens = Score, DigitTens+1 = Score+1
     79 U0086
     80 U0086							; graphic data ready to put into PF1 during display score routine
     81 U0086		       00 00	   ScoreGfx   ds	2	; stored in $86-87
     82 U0088
     83 U0088							; scratch variable
     84 U0088		       00	   Temp       ds	1	; stored in $88
     85 U0089
     86 U0089							; object X positions in $89-8D
     87 U0089		       00 00 00 00*ObjectX    ds	5	; player0, player1, missile0, missile1, ball
     88 U008e
     89 U008e							; object Y positions in $8E-92
     90 U008e		       00 00 00 00*ObjectY    ds	5	; player0, player1, missile0, missile1, ball
     91 U0093
     92 U0093							; DoDraw storage in $93-94
     93 U0093		       00	   Player0Draw ds	1	; used for drawing player0
     94 U0094		       00	   Player1Draw ds	1	; used for drawing player1
     95 U0095
     96 U0095							; DoDraw Graphic Pointers in $95-98
     97 U0095		       00 00	   Player0Ptr ds	2	; used for drawing player0
     98 U0097		       00 00	   Player1Ptr ds	2	; used for drawing player1
     99 U0099
    100 U0099							; frame counter
    101 U0099		       00	   Frame      ds	1	; stored in $99
    102 U009a
    103 U009a		       00 00 00 00*TimerPF    ds	6	; stored in $9A-9F
    104 U00a0		       00	   ArenaColor ds	1	; stored in $A0
    105 U00a1
    106 U00a1							;save player locations for playfield collision logic
    107 U00a1		       00 00	   SavedX     ds	2	; stored in $A1-A2
    108 U00a3		       00 00	   SavedY     ds	2	; stored in $A3-A4
    109 U00a5
    110 U00a5		       00	   Temp2      ds	1	; stored in $A5
    111 U00a6
    112 U00a6							; D7, 1=Game Active, 0=Game Over
    113 U00a6		       00	   GameState  ds	1	; stored in $A6
    114 U00a7							; CODING TIP - There are 8 bits within a byte.  Dx notation is used to
    115 U00a7							;		specify a specific bit where x is 0-7.
    116 U00a7							;		D7 is the high bit, D0 is the low bit.
    117 U00a7							;		D7 and D6 can be quickly tested without trashing any CPU
    118 U00a7							;		registers by using the BIT command.  You can see this in
    119 U00a7							;		action in OverScan where TIA's collision detection registers
    120 U00a7							;		are tested using the BIT command.
    121 U00a7
    122 U00a7							; used for the "screen saver" color cycle effect
    123 U00a7		       00	   ColorCycle ds	1	; stored in $A7
    124 U00a8
    125 U00a8							; game variation
    126 U00a8							; D1 - Arena selection, choice of 2
    127 U00a8							; D0=0 - 1 player, D0=1 - 2 player
    128 U00a8		       00	   Variation  ds	1	; stored in $A8
    129 U00a9
    130 U00a9							; Player variation is also stored as a seperate byte so it can be tested
    131 U00a9							; with the handy BIT command
    132 U00a9							; D7=0 - 1 player, D7=1 - 2 player
    133 U00a9		       00	   Players    ds	1	; stored in $A9
    134 U00aa
    135 U00aa							; Delay game variation change when Select is held
    136 U00aa		       00	   SelectDelay ds	1	; stored in $AA
    137 U00ab
    138 U00ab							; used by Random for an 8 bit random number
    139 U00ab		       00	   Rand8      ds	1	; stored in $AB
    140 U00ac							; optionally define space for Rand16 for 16 bit random number
    141 U00ac		       00	   Rand16     ds	1	; stored in $AC
    142 U00ad
    143 U00ad
    144 U00ad							;===============================================================================
    145 U00ad							; Define Start of Cartridge
    146 U00ad							;===============================================================================
    147 U00ad
    148 U00ad							; define a segment for code
    149  10000 ????				       SEG	CODE
    150  10000 ????
    151  10000 ????						; 2K ROM starts at $F800, 4K ROM starts at $F000
    152  f800					      ORG	$F800
    153  f800
    154  f800							;===============================================================================
    155  f800							; PosObject
    156  f800							;----------
    157  f800							; subroutine for setting the X position of any TIA object
    158  f800							; when called, set the following registers:
    159  f800							;   A - holds the X position of the object
    160  f800							;   X - holds which object to position
    161  f800							;	 0 = player0
    162  f800							;	 1 = player1
    163  f800							;	 2 = missile0
    164  f800							;	 3 = missile1
    165  f800							;	 4 = ball
    166  f800							; the routine will set the coarse X position of the object, as well as the
    167  f800							; fine-tune register that will be used when HMOVE is used.
    168  f800							;===============================================================================
    169  f800				   PosObject
    170  f800		       38		      sec
    171  f801		       85 02		      sta	WSYNC
    172  f803				   DivideLoop
    173  f803		       e9 0f		      sbc	#15	; 2  2 - each time thru this loop takes 5 cycles, which is
    174  f805		       b0 fc		      bcs	DivideLoop	; 2  4 - the same amount of time it takes to draw 15 pixels
    175  f807		       49 07		      eor	#7	; 2  6 - The EOR & ASL statements convert the remainder
    176  f809		       0a		      asl		; 2  8 - of position/15 to the value needed to fine tune
    177  f80a		       0a		      asl		; 2 10 - the X position
    178  f80b		       0a		      asl		; 2 12
    179  f80c		       0a		      asl		; 2 14
    180  f80d		       9d 20 00 	      sta.wx	HMP0,X	; 5 19 - store fine tuning of X
    181  f810		       95 10		      sta	RESP0,X	; 4 23 - set coarse X position of object
    182  f812		       60		      rts		; 6 29
    183  f813
    184  f813
    185  f813							;===============================================================================
    186  f813							; Initialize Atari
    187  f813							;===============================================================================
    188  f813				   InitSystem
    189  f813							; CLEAN_START is a macro found in macro.h
    190  f813							; it sets all RAM, TIA registers and CPU registers to 0
      0  f813					      CLEAN_START
      1  f813		       78		      sei
      2  f814		       d8		      cld
      3  f815
      4  f815		       a2 00		      ldx	#0
      5  f817		       8a		      txa
      6  f818		       a8		      tay
      7  f819		       ca	   .CLEAR_STACK dex
      8  f81a		       9a		      txs
      9  f81b		       48		      pha
     10  f81c		       d0 fb		      bne	.CLEAR_STACK
     11  f81e
    192  f81e
    193  f81e		       20 37 fb 	      jsr	NewGame	; put objects in default position
    194  f821		       e8		      inx		; x was 0, now 1
    195  f822		       86 80		      stx	Score	; display human readable game variation
    196  f824		       86 81		      stx	Score+1	; display human readable player count
    197  f826
    198  f826							; seed the random number generator
    199  f826		       ad 84 02 	      lda	INTIM	; unknown value
    200  f829		       85 ab		      sta	Rand8	; use as seed
    201  f82b		       49 ff		      eor	#$FF	; both seed values cannot be 0, so flip the bits
    202  f82d		       85 ac		      sta	Rand16	;   just in case INTIM was 0
    203  f82f							; from here we "fall into" the main loop
    204  f82f
    205  f82f
    206  f82f							;===============================================================================
    207  f82f							; Main Program Loop
    208  f82f							;===============================================================================
    209  f82f				   Main
    210  f82f		       20 3e f8 	      jsr	VerticalSync	; Jump to SubRoutine VerticalSync
    211  f832		       20 72 f8 	      jsr	VerticalBlank	; Jump to SubRoutine VerticalBlank
    212  f835		       20 8c f8 	      jsr	Kernel	; Jump to SubRoutine Kernel
    213  f838		       20 80 f9 	      jsr	OverScan	; Jump to SubRoutine OverScan
    214  f83b		       4c 2f f8 	      jmp	Main	; JuMP to Main
    215  f83e
    216  f83e
    217  f83e							;===============================================================================
    218  f83e							; Vertical Sync
    219  f83e							; -------------
    220  f83e							; here we generate the signal that tells the TV to move the beam to the top of
    221  f83e							; the screen so we can start the next frame of video.
    222  f83e							; The Sync Signal must be on for 3 scanlines.
    223  f83e							;===============================================================================
    224  f83e				   VerticalSync
    225  f83e		       a9 02		      lda	#2	; LoaD Accumulator with 2 so D1=1
    226  f840		       a2 31		      ldx	#49	; LoaD X with 49
    227  f842		       85 02		      sta	WSYNC	; Wait for SYNC (halts CPU until end of scanline)
    228  f844		       85 00		      sta	VSYNC	; Accumulator D1=1, turns on Vertical Sync signal
    229  f846		       8e 96 02 	      stx	TIM64T	; set timer to go off in 41 scanlines (49 * 64) / 76
    230  f849		       85 0a		      sta	CTRLPF	; D1=1, playfield now in SCORE mode
    231  f84b		       a5 99		      lda	Frame
    232  f84d		       29 3f		      and	#$3f
    233  f84f		       d0 02		      bne	VSskip
    234  f851		       c6 a7		      dec	ColorCycle
    235  f853		       e6 99	   VSskip     inc	Frame	; increment Frame count
    236  f855
    237  f855		       85 02		      sta	WSYNC	; Wait for Sync - halts CPU until end of 1st scanline of VSYNC
    238  f857		       85 02		      sta	WSYNC	; wait until end of 2nd scanline of VSYNC
    239  f859		       a9 00		      lda	#0	; LoaD Accumulator with 0 so D1=0
    240  f85b		       85 0d		      sta	PF0	; blank the playfield
    241  f85d		       85 0e		      sta	PF1	; blank the playfield
    242  f85f		       85 0f		      sta	PF2	; blank the playfield
    243  f861		       85 1b		      sta	GRP0	; blanks player0 if VDELP0 was off
    244  f863		       85 1c		      sta	GRP1	; blanks player0 if VDELP0 was on, player1 if VDELP1 was off
    245  f865		       85 1b		      sta	GRP0	; blanks			    player1 if VDELP1 was on
    246  f867		       85 25		      sta	VDELP0	; turn off Vertical Delay
    247  f869		       85 26		      sta	VDELP1	; turn off Vertical Delay
    248  f86b		       85 2c		      sta	CXCLR	; clear collision detection latches
    249  f86d		       85 02		      sta	WSYNC	; wait until end of 3rd scanline of VSYNC
    250  f86f		       85 00		      sta	VSYNC	; Accumulator D1=0, turns off Vertical Sync signal
    251  f871				   Sleep12		;	 jsr here to sleep for 12 cycles
    252  f871		       60		      rts		; ReTurn from Subroutine
    253  f872
    254  f872
    255  f872							;===============================================================================
    256  f872							; Vertical Blank
    257  f872							; --------------
    258  f872							; game logic runs here.
    259  f872							;===============================================================================
    260  f872				   VerticalBlank
    261  f872		       20 ab fb 	      jsr	Random
    262  f875		       20 fa fa 	      jsr	ProcessSwitches
    263  f878		       24 a6		      bit	GameState
    264  f87a		       10 06		      bpl	NotActive	; skip timer and joystick if game is not active
    265  f87c		       20 c5 f9 	      jsr	UpdateTimer
    266  f87f		       20 ea f9 	      jsr	ProcessJoystick
    267  f882				   NotActive
    268  f882		       20 41 fa 	      jsr	PositionObjects
    269  f885		       20 9a fa 	      jsr	SetObjectColors
    270  f888		       20 da fa 	      jsr	PrepScoreForDisplay
    271  f88b		       60		      rts		; ReTurn from Subroutine
    272  f88c
    273  f88c
    274  f88c							;===============================================================================
    275  f88c							; Kernel
    276  f88c							; ------
    277  f88c							; here we update the registers in TIA, the video chip, scanline by scanline
    278  f88c							; in order to generate what the player sees.
    279  f88c							;
    280  f88c							; Timing is crucial in the kernel, so we need to count the cycles.  You may
    281  f88c							; use your own method of counting cycles, this is how I do it:
    282  f88c							;	 instruction	 ;xx yy - comment
    283  f88c							;   xx = cycles instruction will take
    284  f88c							;   yy = cumulative cycle count after instruction runs
    285  f88c							;   comment = what's going on.  Some instructions have special notation:
    286  f88c							;	 @aa-bb where aa and bb are numbers.  These are used to denote that the
    287  f88c							;	     instruction MUST be done within a range of cycles.  This is especially
    288  f88c							;	     true of updating the playfield where you need to update the register
    289  f88c							;	     twice on a scanline if you want the left and right side of the screen
    290  f88c							;	     to show different images.	If aa > bb that means the instruction can
    291  f88c							;	     be executed on the prior scanline on or after cycle aa.
    292  f88c							;	 (a b) where a and b are numbers.  These are used for branches to show
    293  f88c							;	     the cycles and cycle count if the branch is taken.
    294  f88c							;
    295  f88c							; The following is used to denote when a new scanline starts:
    296  f88c							;---------------------------------------
    297  f88c							;
    298  f88c							;===============================================================================
    299  f88c				   Kernel
    300  f88c		       85 02		      sta	WSYNC	; Wait for SYNC (halts CPU until end of scanline)
    301  f88e							;---------------------------------------
    302  f88e		       ad 84 02 	      lda	INTIM	; 4  4 - check the timer
    303  f891		       d0 f9		      bne	Kernel	; 2  6 - (3 7) Branch if its Not Equal to 0
    304  f893							; turn on the display
    305  f893		       85 01		      sta	VBLANK	; 3  9 - Accumulator D1=0, turns off Vertical Blank signal (image output on)
    306  f895		       a2 05		      ldx	#5	; 2 11 - use X as the loop counter for ScoreLoop
    307  f897
    308  f897							; first thing we draw is the score.  Score is drawn using only PF1 of the
    309  f897							; playfield.  The playfield is set for in repeat mode, and SCORE is turned
    310  f897							; on so the left and right sides take on the colors of player0 and player1.
    311  f897							; To get here we can fall thru from above (cycle 11) OR loop back from below
    312  f897							; (cycle 43). We'll cycle count from the worst case scenario
    313  f897				   ScoreLoop		;   43 - cycle after bpl ScoreLoop
    314  f897		       a4 84		      ldy	DigitTens	; 3 46 - get the tens digit offset for the Score
    315  f899		       b9 00 fc 	      lda	DigitGfx,y	; 5 51 -   use it to load the digit graphics
    316  f89c		       29 f0		      and	#$F0	; 2 53 -   remove the graphics for the ones digit
    317  f89e		       85 86		      sta	ScoreGfx	; 3 56 -   and save it
    318  f8a0		       a4 82		      ldy	DigitOnes	; 3 59 - get the ones digit offset for the Score
    319  f8a2		       b9 00 fc 	      lda	DigitGfx,y	; 5 64 -   use it to load the digit graphics
    320  f8a5		       29 0f		      and	#$0F	; 2 66 -   remove the graphics for the tens digit
    321  f8a7		       05 86		      ora	ScoreGfx	; 3 69 -   merge with the tens digit graphics
    322  f8a9		       85 86		      sta	ScoreGfx	; 3 72 -   and save it
    323  f8ab		       85 02		      sta	WSYNC	; 3 75 - wait for end of scanline
    324  f8ad							;---------------------------------------
    325  f8ad		       85 0e		      sta	PF1	; 3  3 - @66-28, update playfield for Score dislay
    326  f8af		       a4 85		      ldy	DigitTens+1	; 3  6 - get the left digit offset for the Score+1
    327  f8b1		       b9 00 fc 	      lda	DigitGfx,y	; 5 11 -   use it to load the digit graphics
    328  f8b4		       29 f0		      and	#$F0	; 2 13 -   remove the graphics for the ones digit
    329  f8b6		       85 87		      sta	ScoreGfx+1	; 3 16 -   and save it
    330  f8b8		       a4 83		      ldy	DigitOnes+1	; 3 19 - get the ones digit offset for the Score+1
    331  f8ba		       b9 00 fc 	      lda	DigitGfx,y	; 5 24 -   use it to load the digit graphics
    332  f8bd		       29 0f		      and	#$0F	; 2 26 -   remove the graphics for the tens digit
    333  f8bf		       05 87		      ora	ScoreGfx+1	; 3 29 -   merge with the tens digit graphics
    334  f8c1		       85 87		      sta	ScoreGfx+1	; 3 32 -   and save it
    335  f8c3		       20 71 f8 	      jsr	Sleep12	;12 44 - waste some cycles
    336  f8c6		       85 0e		      sta	PF1	; 3 47 - @39-54, update playfield for Score+1 display
    337  f8c8		       a4 86		      ldy	ScoreGfx	; 3 50 - preload for next scanline
    338  f8ca		       85 02		      sta	WSYNC	; 3 53 - wait for end of scanline
    339  f8cc							;---------------------------------------
    340  f8cc		       84 0e		      sty	PF1	; 3  3 - update playfield for the Score display
    341  f8ce		       e6 84		      inc	DigitTens	; 5  8 - advance for the next line of graphic data
    342  f8d0		       e6 85		      inc	DigitTens+1	; 5 13 - advance for the next line of graphic data
    343  f8d2		       e6 82		      inc	DigitOnes	; 5 18 - advance for the next line of graphic data
    344  f8d4		       e6 83		      inc	DigitOnes+1	; 5 23 - advance for the next line of graphic data
    345  f8d6		       20 71 f8 	      jsr	Sleep12	;12 35 - waste some cycles
    346  f8d9		       ca		      dex		; 2 37 - decrease the loop counter
    347  f8da		       85 0e		      sta	PF1	; 3 40 - @39-54, update playfield for the Score+1 display
    348  f8dc		       d0 b9		      bne	ScoreLoop	; 2 42 - (3 43) if dex != 0 then branch to ScoreLoop
    349  f8de		       85 02		      sta	WSYNC	; 3 45 - wait for end of scanline
    350  f8e0							;---------------------------------------
    351  f8e0		       86 0e		      stx	PF1	; 3  3 - x = 0, so this blanks out playfield
    352  f8e2		       85 02		      sta	WSYNC	; 3  6 - wait for end of scanline
    353  f8e4							;---------------------------------------
    354  f8e4		       a9 00		      lda	#0	; 2  2
    355  f8e6		       85 0a		      sta	CTRLPF	; 3  5 - turn off SCORE mode
    356  f8e8		       a2 01		      ldx	#1	; 2  7
    357  f8ea							; draw timer bar
    358  f8ea				   TimerBar
    359  f8ea		       85 02		      sta	WSYNC	; 3
    360  f8ec							;---------------------------------------
    361  f8ec		       a5 9a		      lda	TimerPF	; 3  3
    362  f8ee		       85 0d		      sta	PF0	; 3  6
    363  f8f0		       a5 9b		      lda	TimerPF+1	; 3  9
    364  f8f2		       85 0e		      sta	PF1	; 3 12
    365  f8f4		       a5 9c		      lda	TimerPF+2	; 3 15
    366  f8f6		       85 0f		      sta	PF2	; 3 18
      0  f8f8					      SLEEP	20	;20 38
      1  f8f8				   .CYCLES    SET	20
      2  f8f8
      3  f8f8				  -	      IF	.CYCLES < 2
      4  f8f8				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f8f8				  -	      ERR
      6  f8f8					      ENDIF
      7  f8f8
      8  f8f8				  -	      IF	.CYCLES & 1
      9  f8f8				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f8f8				  -	      nop	0
     11  f8f8				  -	      ELSE
     12  f8f8				  -	      bit	VSYNC
     13  f8f8				  -	      ENDIF
     14  f8f8				  -.CYCLES    SET	.CYCLES - 3
     15  f8f8					      ENDIF
     16  f8f8
     17  f8f8					      REPEAT	.CYCLES / 2
     18  f8f8		       ea		      nop
     17  f8f8					      REPEND
     18  f8f9		       ea		      nop
     17  f8f9					      REPEND
     18  f8fa		       ea		      nop
     17  f8fa					      REPEND
     18  f8fb		       ea		      nop
     17  f8fb					      REPEND
     18  f8fc		       ea		      nop
     17  f8fc					      REPEND
     18  f8fd		       ea		      nop
     17  f8fd					      REPEND
     18  f8fe		       ea		      nop
     17  f8fe					      REPEND
     18  f8ff		       ea		      nop
     17  f8ff					      REPEND
     18  f900		       ea		      nop
     17  f900					      REPEND
     18  f901		       ea		      nop
     19  f902					      REPEND
    368  f902		       a5 9d		      lda	TimerPF+3	; 3 41
    369  f904		       85 0d		      sta	PF0	; 3 44
    370  f906		       a5 9e		      lda	TimerPF+4	; 3 47
    371  f908		       85 0e		      sta	PF1	; 3 50
    372  f90a		       a5 9f		      lda	TimerPF+5	; 3 53
    373  f90c		       85 0f		      sta	PF2	; 3 56
    374  f90e		       ca		      dex		; 2 58
    375  f90f		       10 d9		      bpl	TimerBar	; 2 60 (3 61)
    376  f911		       85 02		      sta	WSYNC	; 3 63
    377  f913							;---------------------------------------
    378  f913		       a9 00		      lda	#0	; 2  2
    379  f915		       85 0d		      sta	PF0	; 3  5
    380  f917		       85 0e		      sta	PF1	; 3  8
    381  f919		       85 0f		      sta	PF2	; 3 11
    382  f91b		       a5 a0		      lda	ArenaColor	; 3 14
    383  f91d		       85 08		      sta	COLUPF	; 3 17
    384  f91f		       a5 a8		      lda	Variation	; 3 20
    385  f921		       4a		      lsr		; 2 22 - which Arena to show
    386  f922		       a8		      tay		; 2 24 - set for index
    387  f923		       be 7e f9 	      ldx	ArenaOffset,y	; 4 28 - set X for which arena to draw
    388  f926		       bd 4b fc 	      lda	ArenaPF0,x	; 4 32 - reflect and priority for playfield
    389  f929		       29 07		      and	#%00000111	; 2 34 - get the lower 3 bits for CTRLPF
    390  f92b		       09 30		      ora	#%00110000	; 2 36 - set ball to display as 8x pixel
    391  f92d		       85 0a		      sta	CTRLPF	; 3 39
    392  f92f		       85 02		      sta	WSYNC	; 3 20 - gab between timer and Arena
    393  f931							;---------------------------------------
    394  f931
    395  f931							; The Arena is drawn using what is known as a 2 line kernel, or 2LK for
    396  f931							; short. Basically the code is designed so that the TIA register updates are
    397  f931							; spread out over 2 scanlines instead of one.	TIA has a feature for the
    398  f931							; player objects, as well as the ball, called Vertical Delay which allows
    399  f931							; the objects to still start on any scanline even though they are only
    400  f931							; updated every-other scanline.  Vertical Delay is controlled by the TIA
    401  f931							; registers VDELP0, VDELP1 and VDELBL.
    402  f931							;
    403  f931							; ArenaLoop:
    404  f931							;	 line 1 - updates player1, playfield
    405  f931							;	 line 2 - updates player0
    406  f931							;	 if not at bottom, goto ArenaLoop
    407  f931
    408  f931							; we need to preload GRP0 so that player0 can appear on the very first
    409  f931							; scanline of the Arena
    410  f931
    411  f931		       a0 58		      ldy	#ARENA_HEIGHT+1	; 2  7 - the arena will be 180 scanlines (from 0-89)*2
    412  f933
    413  f933							; prime GRP0 so player0 can appear on topmost scanline of the Arena
    414  f933		       a9 09		      lda	#HUMAN_HEIGHT-1	; 2 12 - height of player0 graphics,
    415  f935		       c7 93		      dcp	Player0Draw	; 5 17 - Decrement Player0Draw and compare with height
    416  f937		       b0 03		      bcs	DoDrawGrp0pre	; 2 19 - (3 20) if Carry is Set, then player0 is on current scanline
    417  f939		       a9 00		      lda	#0	; 2 21 - otherwise use 0 to turn off player0
    418  f93b		       2c		      .byte.b	$2C	; 4 25 - $2C = BIT with absolute addressing, trick that
    419  f93c							;	  causes the lda (Player0Ptr),y to be skipped
    420  f93c				   DoDrawGrp0pre		;   20 - from bcs DoDrawGRP0pre
    421  f93c		       b1 95		      lda	(Player0Ptr),y	; 5 25 - load the shape for player0
    422  f93e		       85 1b		      sta	GRP0	; 3 28 - @0-22, update player0 graphics
    423  f940		       88		      dey		; 2 30
    424  f941
    425  f941				   ArenaLoop		;   30 - (currently 7 from bpl ArenaLoop)
    426  f941		       98		      tya		; 2 32 - 2LK loop counter in A for testing
    427  f942		       29 03		      and	#%11	; 2 34 - test for every 4th time through the loop,
    428  f944		       d0 01		      bne	SkipX	; 2 36 (3 37) branch if not 4th time
    429  f946		       e8		      inx		; 2 38 - if 4th time, increase X so new playfield data is used
    430  f947				   SkipX		;   38 - use 38 as it's the longest path here
    431  f947
    432  f947							; continuation of line 2 of the 2LK
    433  f947							; this precalculates data that's used on line 1 of the 2LK
    434  f947		       a9 09		      lda	#HUMAN_HEIGHT-1	; 2 40 - height of the humanoid graphics, subtract 1 due to starting with 0
    435  f949		       c7 94		      dcp	Player1Draw	; 5 45 - Decrement Player1Draw and compare with height
    436  f94b		       b0 03		      bcs	DoDrawGrp1	; 2 47 - (3 48) if Carry is Set, then player1 is on current scanline
    437  f94d		       a9 00		      lda	#0	; 2 49 - otherwise use 0 to turn off player1
    438  f94f		       2c		      .byte.b	$2C	; 4 53 - $2C = BIT with absolute addressing, trick that
    439  f950							;	  causes the lda (Player1Ptr),y to be skipped
    440  f950				   DoDrawGrp1		;   48 - from bcs DoDrawGrp1
    441  f950		       b1 97		      lda	(Player1Ptr),y	; 5 53 - load the shape for player1
    442  f952		       85 02		      sta	WSYNC	; 3 56
    443  f954							;---------------------------------------
    444  f954							; start of line 1 of the 2LK
    445  f954		       85 1c		      sta	GRP1	; 3  3 - @0-22, update player1 graphics
    446  f956		       bd 4b fc 	      lda	ArenaPF0,x	; 4  7 - get current scanline's playfield pattern
    447  f959		       85 0d		      sta	PF0	; 3 10 - @0-22 and update it
    448  f95b		       bd 77 fc 	      lda	ArenaPF1,x	; 4 14 - get current scanline's playfield pattern
    449  f95e		       85 0e		      sta	PF1	; 3 17 - @71-28 and update it
    450  f960		       bd a3 fc 	      lda	ArenaPF2,x	; 4 21 - get current scanline's playfield pattern
    451  f963		       85 0f		      sta	PF2	; 3 24 - @60-39
    452  f965
    453  f965							; precalculate data that's needed for line 2 of the 2LK
    454  f965		       a9 09		      lda	#HUMAN_HEIGHT-1	; 2 26 - height of the box graphics,
    455  f967		       c7 93		      dcp	Player0Draw	; 5 31 - Decrement Player0Draw and compare with height
    456  f969		       b0 03		      bcs	DoDrawGrp0	; 2 33 - (3 34) if Carry is Set then player0 is on current scanline
    457  f96b		       a9 00		      lda	#0	; 2 35 - otherwise use 0 to turn off player0
    458  f96d		       2c		      .byte.b	$2C	; 4 39 - $2C = BIT with absolute addressing, trick that
    459  f96e							;	  causes the lda (Player0Ptr),y to be skipped
    460  f96e				   DoDrawGrp0		;   34 - from bcs DoDrawGRP0
    461  f96e		       b1 95		      lda	(Player0Ptr),y	; 5 39 - load the shape for player0
    462  f970		       85 02		      sta	WSYNC	; 3 42
    463  f972							;---------------------------------------
    464  f972							; start of line 2 of the 2LK
    465  f972		       85 1b		      sta	GRP0	; 3  3 - @0-22, update player0 graphics
    466  f974		       88		      dey		; 2  5 - decrease the 2LK loop counter
    467  f975		       d0 ca		      bne	ArenaLoop	; 2  7 - (3  8) branch if there's more Arena to draw
    468  f977		       84 0d		      sty	PF0	; 3 10 - Y is 0, blank out playfield
    469  f979		       84 0e		      sty	PF1	; 3 13 - Y is 0, blank out playfield
    470  f97b		       84 0f		      sty	PF2	; 3 16 - Y is 0, blank out playfield
    471  f97d		       60		      rts		; 6 22 - ReTurn from Subroutine
    472  f97e
    473  f97e				   ArenaOffset
    474  f97e		       00		      .byte.b	0	; Arena 1
    475  f97f		       16		      .byte.b	22	; Arena 2
    476  f980
    477  f980							;===============================================================================
    478  f980							; Overscan
    479  f980							; --------------
    480  f980							; If game is active, Process Object Collisions
    481  f980							;===============================================================================
    482  f980				   OverScan
    483  f980		       85 02		      sta	WSYNC	; Wait for SYNC (halts CPU until end of scanline)
    484  f982		       a9 02		      lda	#2	; LoaD Accumulator with 2 so D1=1
    485  f984		       85 01		      sta	VBLANK	; STore Accumulator to VBLANK, D1=1 turns image output off
    486  f986
    487  f986							; set the timer so the total number of scanlines ends up being 262
    488  f986		       a9 23		      lda	#35
    489  f988		       8d 96 02 	      sta	TIM64T
    490  f98b
    491  f98b		       24 a6		      bit	GameState	; check if the game is active
    492  f98d		       30 03		      bmi	TestCollisions	; if so, process collisions
    493  f98f		       4c bd f9 	      jmp	OSwait	; else wait for OS to be over
    494  f992
    495  f992				   TestCollisions
    496  f992							; Test left player collisions
    497  f992		       a0 00		      ldy	#0	; which score to update if box collected
    498  f994		       24 02		      bit	CXP0FB	; N = player0/playfield, V=player0/ball
    499  f996		       10 08		      bpl	notP0PF	; if N is off, then player0 did not collide with playfield
    500  f998		       a5 a1		      lda	SavedX	; recall saved X
    501  f99a		       85 89		      sta	ObjectX	; and move player back to it
    502  f99c		       a5 a3		      lda	SavedY	; recall saved Y
    503  f99e		       85 8e		      sta	ObjectY	; and move player back to it
    504  f9a0				   notP0PF
    505  f9a0
    506  f9a0		       24 a9		      bit	Players	; test how many players are in this game variation
    507  f9a2		       30 0c		      bmi	RightPlayer	; test Right Player collisions if its a 2 player game
    508  f9a4		       24 07		      bit	CXPPMM	; else see if left player collected box drawn by player1
    509  f9a6		       10 15		      bpl	OSwait	; player0 did not collide wth player1
    510  f9a8		       a2 01		      ldx	#1	; which box was collected
    511  f9aa		       20 9c fb 	      jsr	CollectBox	; update score and reposition box
    512  f9ad		       4c bd f9 	      jmp	OSwait	; 1 player game, so skip Right Player test
    513  f9b0
    514  f9b0				   RightPlayer
    515  f9b0							; Test right player collisions
    516  f9b0		       c8		      iny		; which score to update if box collected
    517  f9b1		       24 03		      bit	CXP1FB	; N = player1/playfield, V=player1/ball
    518  f9b3		       10 08		      bpl	notP1PF	; if N is off, then player1 did not collide with playfield
    519  f9b5		       a5 a2		      lda	SavedX+1	; recall saved X
    520  f9b7		       85 8a		      sta	ObjectX+1	; and move player back to it
    521  f9b9		       a5 a4		      lda	SavedY+1	; recall saved Y
    522  f9bb		       85 8f		      sta	ObjectY+1	; and move player back to it
    523  f9bd				   notP1PF
    524  f9bd
    525  f9bd				   OSwait
    526  f9bd		       85 02		      sta	WSYNC	; Wait for SYNC (halts CPU until end of scanline)
    527  f9bf		       ad 84 02 	      lda	INTIM	; Check the Timer
    528  f9c2		       d0 f9		      bne	OSwait	; Branch if its Not Equal to 0
    529  f9c4		       60		      rts		; ReTurn from Subroutine
    530  f9c5
    531  f9c5
    532  f9c5							;===============================================================================
    533  f9c5							; UpdateTimer
    534  f9c5							; -----------
    535  f9c5							; udpates timer display
    536  f9c5							;===============================================================================
    537  f9c5				   UpdateTimer
    538  f9c5		       a5 99		      lda	Frame
    539  f9c7		       29 3f		      and	#63
    540  f9c9		       f0 01		      beq	TimerTick	; tick the timer once every 64 frames
    541  f9cb		       60		      rts
    542  f9cc
    543  f9cc				   TimerTick
    544  f9cc		       a5 9a		      lda	TimerPF	; get TimerPF
    545  f9ce		       29 f0		      and	#%11110000	; and chop off the lower nybble
    546  f9d0		       d0 05		      bne	DecrementTimer	; if the upper nybble is not 0 then time remains
    547  f9d2		       a9 00		      lda	#0	; otherwise time ran out so end the game
    548  f9d4		       85 a6		      sta	GameState
    549  f9d6		       60		      rts
    550  f9d7
    551  f9d7				   DecrementTimer
    552  f9d7		       46 9f		      lsr	TimerPF+5	; PF2 right side, reversed bits so shift right
    553  f9d9		       26 9e		      rol	TimerPF+4	; PF1 right side, normal bits so shift left
    554  f9db		       66 9d		      ror	TimerPF+3	; PF0 right side, reversed bits so shift right
    555  f9dd		       a5 9d		      lda	TimerPF+3	; only upper nybble used, so we need to put bit 3 into C
    556  f9df		       4a		      lsr
    557  f9e0		       4a		      lsr
    558  f9e1		       4a		      lsr
    559  f9e2		       4a		      lsr
    560  f9e3		       66 9c		      ror	TimerPF+2	; PF2 left side, reversed bits so shift right
    561  f9e5		       26 9b		      rol	TimerPF+1	; PF1 left side, normal bits so shift left
    562  f9e7		       66 9a		      ror	TimerPF	; PF0 left side, reversed bits so shift right
    563  f9e9		       60		      rts
    564  f9ea
    565  f9ea
    566  f9ea							;===============================================================================
    567  f9ea							; ProcessJoystick
    568  f9ea							; --------------
    569  f9ea							; Read joysticks and move humanoids
    570  f9ea							;
    571  f9ea							; joystick directions are held in the SWCHA register of the RIOT chip.
    572  f9ea							; Directions are read via the following bit pattern:
    573  f9ea							;   76543210
    574  f9ea							;   RLDUrldu	 - RIGHT LEFT DOWN UP right left down up
    575  f9ea							;
    576  f9ea							; UPPERCASE denotes the left joystick directions
    577  f9ea							; lowercase denotes the right joystick directions
    578  f9ea							;
    579  f9ea							; NOTE the values are the opposite of what you might expect. If the direction
    580  f9ea							; is held, the bit value will be 0.
    581  f9ea							;
    582  f9ea							; Fire buttons are read via INPT4 (left) and INPT5 (right).  They are
    583  f9ea							; not used in Collect.
    584  f9ea							;===============================================================================
    585  f9ea				   ProcessJoystick
    586  f9ea		       ad 80 02 	      lda	SWCHA	; reads joystick positions
    587  f9ed
    588  f9ed		       a2 00		      ldx	#0	; x=0 for left joystick, x=1 for right
    589  f9ef				   PJloop
    590  f9ef		       b4 89		      ldy	ObjectX,x	; save original X location so the player can be
    591  f9f1		       94 a1		      sty	SavedX,x	;   bounced back upon colliding with the playfield
    592  f9f3		       b4 8e		      ldy	ObjectY,x	; save original Y location so the player can be
    593  f9f5		       94 a3		      sty	SavedY,x	;   bounced back upon colliding with the playfield
    594  f9f7		       0a		      asl		; shift A bits left, R is now in the carry bit
    595  f9f8		       b0 0f		      bcs	CheckLeft	; branch if joystick is not held right
    596  f9fa		       b4 89		      ldy	ObjectX,x	; get the object's X position
    597  f9fc		       c8		      iny		; and move it right
    598  f9fd		       c0 a0		      cpy	#160	; test for edge of screen
    599  f9ff		       d0 02		      bne	SaveX	; save Y if we're not at the edge
    600  fa01		       a0 00		      ldy	#0	; else wrap to left edge
    601  fa03		       94 89	   SaveX      sty	ObjectX,x	; saveX
    602  fa05		       a0 00		      ldy	#0	; turn off reflect of player, which
    603  fa07		       94 0b		      sty	REFP0,x	; makes humanoid image face right
    604  fa09
    605  fa09				   CheckLeft
    606  fa09		       0a		      asl		; shift A bits left, L is now in the carry bit
    607  fa0a		       b0 0f		      bcs	CheckDown	; branch if joystick not held left
    608  fa0c		       b4 89		      ldy	ObjectX,x	; get the object's X position
    609  fa0e		       88		      dey		; and move it left
    610  fa0f		       c0 ff		      cpy	#255	; test for edge of screen
    611  fa11		       d0 02		      bne	SaveX2	; save X if we're not at the edge
    612  fa13		       a0 9f		      ldy	#159	; else wrap to right edge
    613  fa15		       94 89	   SaveX2     sty	ObjectX,x	; save X
    614  fa17		       a0 08		      ldy	#8	; turn on reflect of player, which
    615  fa19		       94 0b		      sty	REFP0,x	; makes humanoid image face left
    616  fa1b
    617  fa1b				   CheckDown
    618  fa1b		       0a		      asl		; shift A bits left, D is now in the carry bit
    619  fa1c		       b0 0b		      bcs	CheckUp	; branch if joystick not held down
    620  fa1e		       b4 8e		      ldy	ObjectY,x	; get the object's Y position
    621  fa20		       88		      dey		; move it down
    622  fa21		       c0 ff		      cpy	#255	; test for bottom of screen
    623  fa23		       d0 02		      bne	SaveY	; save Y if we're not at the bottom
    624  fa25		       a0 af		      ldy	#ARENA_HEIGHT*2+1	; else wrap to top
    625  fa27		       94 8e	   SaveY      sty	ObjectY,x	; save Y
    626  fa29
    627  fa29				   CheckUp
    628  fa29		       0a		      asl		; shift A bits left, U is now in the carry bit
    629  fa2a		       b0 0b		      bcs	NextJoystick	; branch if joystick not held up
    630  fa2c		       b4 8e		      ldy	ObjectY,x	; get the object's Y position
    631  fa2e		       c8		      iny		; move it up
    632  fa2f		       c0 b0		      cpy	#ARENA_HEIGHT*2+2	; test for top of screen
    633  fa31		       d0 02		      bne	SaveY2	; save Y if we're not at the top
    634  fa33		       a0 00		      ldy	#0	; else wrap to bottom
    635  fa35		       94 8e	   SaveY2     sty	ObjectY,x	; save Y
    636  fa37
    637  fa37				   NextJoystick
    638  fa37		       24 a9		      bit	Players	; test number of players by putting D7 into N
    639  fa39		       10 05		      bpl	OnePlayer	; if N is off, it's a 1 player game so abort loop
    640  fa3b		       e8		      inx		; increase loop control
    641  fa3c		       e0 02		      cpx	#2	; check if we've processed both joysticks
    642  fa3e		       d0 af		      bne	PJloop	; branch if we haven't
    643  fa40				   OnePlayer
    644  fa40		       60		      rts
    645  fa41
    646  fa41
    647  fa41							;===============================================================================
    648  fa41							; PositionObjects
    649  fa41							; --------------
    650  fa41							; Updates TIA for X position of all objects
    651  fa41							; Updates Kernel variables for Y position of all objects
    652  fa41							;===============================================================================
    653  fa41				   PositionObjects
    654  fa41		       a2 01		      ldx	#1	; position objects 0-1: player0 and player1
    655  fa43				   POloop
    656  fa43		       b5 89		      lda	ObjectX,x	; get the object's X position
    657  fa45		       20 00 f8 	      jsr	PosObject	; set coarse X position and fine-tune amount
    658  fa48		       ca		      dex		; DEcrement X
    659  fa49		       10 f8		      bpl	POloop	; Branch PLus so we position all objects
    660  fa4b		       85 02		      sta	WSYNC	; wait for end of scanline
    661  fa4d		       85 2a		      sta	HMOVE	; use fine-tune values to set final X positions
    662  fa4f
    663  fa4f							; prep player 1's Y position for 2LK
    664  fa4f		       a2 01		      ldx	#1	; preload X for setting VDELPx
    665  fa51		       a5 8e		      lda	ObjectY	; get the human's Y position
    666  fa53		       18		      clc
    667  fa54		       69 01		      adc	#1	; add 1 to compensate for priming of GRP0
    668  fa56		       4a		      lsr		; divide by 2 for the 2LK position
    669  fa57		       85 88		      sta	Temp	; save for position calculations
    670  fa59		       b0 02		      bcs	NoDelay0	; if carry is set we don't need Vertical Delay
    671  fa5b		       86 25		      stx	VDELP0	; carry was clear, so set Vertical Delay
    672  fa5d				   NoDelay0
    673  fa5d							; Player0Draw = ARENA_HEIGHT + HUMAN_HEIGHT - Y position + 1
    674  fa5d							; the + 1 compensates for priming of GRP0
    675  fa5d		       a9 62		      lda	#(ARENA_HEIGHT + HUMAN_HEIGHT + 1)
    676  fa5f		       38		      sec
    677  fa60		       e5 88		      sbc	Temp
    678  fa62		       85 93		      sta	Player0Draw
    679  fa64
    680  fa64							; Player0Ptr = HumanGfx + HUMAN_HEIGHT - 1 - Y position
    681  fa64		       a9 40		      lda	#<(HumanGfx + HUMAN_HEIGHT - 1)
    682  fa66		       38		      sec
    683  fa67		       e5 88		      sbc	Temp
    684  fa69		       85 95		      sta	Player0Ptr
    685  fa6b		       a9 fc		      lda	#>(HumanGfx + HUMAN_HEIGHT - 1)
    686  fa6d		       e9 00		      sbc	#0
    687  fa6f		       85 96		      sta	Player0Ptr+1
    688  fa71
    689  fa71							; prep player 2's Y position for 2LK
    690  fa71		       a5 8f		      lda	ObjectY+1	; get the box's Y position
    691  fa73		       4a		      lsr		; divide by 2 for the 2LK position
    692  fa74		       85 88		      sta	Temp	; save for position calculations
    693  fa76		       b0 02		      bcs	NoDelay1	; if carry is set we don't need Vertical Delay
    694  fa78		       86 26		      stx	VDELP1	; carry was clear, so set Vertical Delay
    695  fa7a				   NoDelay1
    696  fa7a							; Player1Draw = ARENA_HEIGHT + HUMAN_HEIGHT - Y position + 1
    697  fa7a		       a9 61		      lda	#(ARENA_HEIGHT + HUMAN_HEIGHT)
    698  fa7c		       38		      sec
    699  fa7d		       e5 88		      sbc	Temp
    700  fa7f		       85 94		      sta	Player1Draw
    701  fa81
    702  fa81		       a5 a8		      lda	Variation	; get the game variation
    703  fa83		       29 01		      and	#1	; and find out if we're 1 or 2 player
    704  fa85		       aa		      tax
    705  fa86							; Player1Ptr = BoxGfx + HUMAN_HEIGHT - 1 - Y position
    706  fa86		       bd 96 fa 	      lda	ShapePtrLow,x
    707  fa89		       38		      sec
    708  fa8a		       e5 88		      sbc	Temp
    709  fa8c		       85 97		      sta	Player1Ptr
    710  fa8e		       bd 98 fa 	      lda	ShapePtrHi,x
    711  fa91		       e9 00		      sbc	#0
    712  fa93		       85 98		      sta	Player1Ptr+1
    713  fa95
    714  fa95		       60		      rts
    715  fa96
    716  fa96				   ShapePtrLow
    717  fa96		       4a		      .byte.b	<(BoxGfx + HUMAN_HEIGHT - 1)
    718  fa97		       40		      .byte.b	<(HumanGfx + HUMAN_HEIGHT - 1)
    719  fa98
    720  fa98				   ShapePtrHi
    721  fa98		       fc		      .byte.b	>(BoxGfx + HUMAN_HEIGHT - 1)
    722  fa99		       fc		      .byte.b	>(HumanGfx + HUMAN_HEIGHT - 1)
    723  fa9a
    724  fa9a							;===============================================================================
    725  fa9a							; SetObjectColors
    726  fa9a							; --------------
    727  fa9a							; Set the 4 color registers based on the state of TV Type.
    728  fa9a							;
    729  fa9a							; If game is inactive then manipulate the colors for the "screen saver"
    730  fa9a							; color cycling effect.
    731  fa9a							;===============================================================================
    732  fa9a				   SetObjectColors
    733  fa9a		       a9 ff		      lda	#$FF
    734  fa9c		       85 a5		      sta	Temp2	; default to color mask
    735  fa9e		       25 a7		      and	ColorCycle	; color cycle
    736  faa0		       24 a6		      bit	GameState
    737  faa2		       10 02		      bpl	SOCgameover
    738  faa4		       a9 00		      lda	#0	; if game is active, no color cycle
    739  faa6				   SOCgameover
    740  faa6		       85 88		      sta	Temp
    741  faa8		       a2 04		      ldx	#4	; we're going to set 5 colors (0-4)
    742  faaa		       a0 04		      ldy	#4	; default to the color entries in the table (0-4)
    743  faac		       ad 82 02 	      lda	SWCHB	; read the state of the console switches
    744  faaf		       29 08		      and	#%00001000	; test state of D3, the TV Type switch
    745  fab1		       d0 06		      bne	SOCloop	; if D3=1 then use color
    746  fab3		       a0 0f		      ldy	#$0f
    747  fab5		       84 a5		      sty	Temp2	; set B&W mask
    748  fab7		       a0 09		      ldy	#9	; and use the b&w entries in the table (5-9)
    749  fab9				   SOCloop
    750  fab9		       b9 d0 fa 	      lda	Colors,y	; get the color or b&w value
    751  fabc		       45 88		      eor	Temp	; color cycle
    752  fabe		       25 a5		      and	Temp2	; B&W mask
    753  fac0		       95 05		      sta	COLUP0-1,x	; and set it
    754  fac2		       88		      dey		; decrease Y
    755  fac3		       ca		      dex		; decrease X
    756  fac4		       d0 f3		      bne	SOCloop	; Branch Not Equal to Zero
    757  fac6		       b9 d0 fa 	      lda	Colors,y	; get the Arena color
    758  fac9		       45 88		      eor	Temp	; color cycle
    759  facb		       25 a5		      and	Temp2	; B&W mask
    760  facd		       85 a0		      sta	ArenaColor	; save in RAM for Kernal Usage
    761  facf
    762  facf		       60		      rts		; ReTurn from Subroutine
    763  fad0
    764  fad0				   Colors
    765  fad0		       46		      .byte.b	$46	; red	      - goes into COLUPF, color for Arena (after Timer is drawn)
    766  fad1		       86		      .byte.b	$86	; blue       - goes into COLUP0, color for player0 and missile0
    767  fad2		       c6		      .byte.b	$C6	; green      - goes into COLUP1, color for player1 and missile1
    768  fad3		       64		      .byte.b	$64	; purple     - goes into COLUPF, color for Timer
    769  fad4		       00		      .byte.b	$00	; black      - goes into COLUBK, color for background
    770  fad5		       0a		      .byte.b	$0A	; light grey - goes into COLUPF, color for Arena (after Timer is drawn)
    771  fad6		       0e		      .byte.b	$0E	; white      - goes into COLUP0, color for player0 and missile0
    772  fad7		       06		      .byte.b	$06	; dark grey  - goes into COLUP1, color for player1 and missile1
    773  fad8		       04		      .byte.b	$04	; dark grey  - goes into COLUPF, color for Timer
    774  fad9		       00		      .byte.b	$00	; black      - goes into COLUBK, color for background
    775  fada
    776  fada
    777  fada							;===============================================================================
    778  fada							; PrepScoreForDisplay
    779  fada							; --------------
    780  fada							; Converts the high and low nybbles of the RAM variables Score and Score+1
    781  fada							; into offsets into the digit graphics so the values can be displayed.
    782  fada							; Each digit uses 5 bytes of data for the graphics.  For the low nybble we need
    783  fada							; to multiply by 5, but the 6507 does not have a multiply feature.  It can,
    784  fada							; however, shift the bits in a byte left, which is the same as a multiply by 2.
    785  fada							; Using this, we can get multiply a # by 5 like this:
    786  fada							;	 # * 5 = (# * 2 * 2) + #
    787  fada							; The value in the upper nybble is already times 16, so we need to divide it.
    788  fada							; The 6507 can shift the bits the right, which is the same as divide by 2.
    789  fada							;	 (# / 16) * 5 = (# / 2 / 2) + (# / 2 / 2 / 2 / 2)
    790  fada							;===============================================================================
    791  fada				   PrepScoreForDisplay
    792  fada		       a2 01		      ldx	#1	; use X as the loop counter for PSFDloop
    793  fadc				   PSFDloop
    794  fadc		       b5 80		      lda	Score,x	; LoaD A with Score+1(first pass) or Score(second pass)
    795  fade		       29 0f		      and	#$0F	; remove the tens digit
    796  fae0		       85 88		      sta	Temp	; Store A into Temp
    797  fae2		       0a		      asl		; Accumulator Shift Left (# * 2)
    798  fae3		       0a		      asl		; Accumulator Shift Left (# * 4)
    799  fae4		       65 88		      adc	Temp	; ADd with Carry value in Temp (# * 5)
    800  fae6		       95 82		      sta	DigitOnes,x	; STore A in DigitOnes+1(first pass) or DigitOnes(second pass)
    801  fae8		       b5 80		      lda	Score,x	; LoaD A with Score+1(first pass) or Score(second pass)
    802  faea		       29 f0		      and	#$F0	; remove the ones digit
    803  faec		       4a		      lsr		; Logical Shift Right (# / 2)
    804  faed		       4a		      lsr		; Logical Shift Right (# / 4)
    805  faee		       85 88		      sta	Temp	; Store A into Temp
    806  faf0		       4a		      lsr		; Logical Shift Right (# / 8)
    807  faf1		       4a		      lsr		; Logical Shift Right (# / 16)
    808  faf2		       65 88		      adc	Temp	; ADd with Carry value in Temp ((# / 16) * 5)
    809  faf4		       95 84		      sta	DigitTens,x	; STore A in DigitTens+1(first pass) or DigitTens(second pass)
    810  faf6		       ca		      dex		; DEcrement X by 1
    811  faf7		       10 e3		      bpl	PSFDloop	; Branch PLus (positive) to PSFDloop
    812  faf9		       60		      rts		; ReTurn from Subroutine
    813  fafa
    814  fafa
    815  fafa							;===============================================================================
    816  fafa							; ProcessSwitches
    817  fafa							; --------------
    818  fafa							; This routine processes the SELECT and RESET switches on the console.  The
    819  fafa							; state of the console switches is in the SWCHB register.
    820  fafa							;   - D7    Right Difficulty	 0=Beginner  1=Advanced
    821  fafa							;   - D6    Left Difficulty	 0=Beginner  1=Advanced
    822  fafa							;   - D5    not used
    823  fafa							;   - D4    not used
    824  fafa							;   - D3    TV Type		 0=B&W	     1=Color
    825  fafa							;   - D2    not used
    826  fafa							;   - D1    SELECT		 0=Pressed   1= Not Pressed
    827  fafa							;   - D0    RESET		 0=Pressed   1= Not Pressed
    828  fafa							;===============================================================================
    829  fafa				   ProcessSwitches
    830  fafa		       ad 82 02 	      lda	SWCHB	; load in the state of the switches
    831  fafd		       4a		      lsr		; D0 is now in C
    832  fafe		       b0 09		      bcs	NotReset	; if D0 was on, the RESET switch was not held
    833  fb00		       20 37 fb 	      jsr	NewGame	; Prep for new game
    834  fb03		       a9 80		      lda	#%10000000
    835  fb05		       85 a6		      sta	GameState	; set D7 on to signify Game Active
    836  fb07		       d0 29		      bne	NotSelect	; clear SelectDelay
    837  fb09
    838  fb09				   NotReset
    839  fb09		       4a		      lsr		; D1 is now in C
    840  fb0a		       b0 26		      bcs	NotSelect	; if D1 was on, the SELECT switch was not held
    841  fb0c		       a9 00		      lda	#0
    842  fb0e		       85 a6		      sta	GameState	; clear D7 to signify Game Over    
    843  fb10		       a5 aa		      lda	SelectDelay	; do we need to delay the Select switch?
    844  fb12		       f0 03		      beq	SelectOK	; if delay is 0 then no
    845  fb14		       c6 aa		      dec	SelectDelay	; else decrement the delay
    846  fb16		       60		      rts		; and exit the subroutine
    847  fb17
    848  fb17				   SelectOK
    849  fb17		       a9 3c		      lda	#60	; Set the Select Delay to 1 second
    850  fb19		       85 aa		      sta	SelectDelay	;
    851  fb1b		       a6 a8		      ldx	Variation	; Get the Game Variation
    852  fb1d		       e8		      inx		; and increase it
    853  fb1e		       8a		      txa		; transfer it to A
    854  fb1f		       29 03		      and	#%00000011	; limit Variation to 0-3
    855  fb21		       85 a8		      sta	Variation	; save it
    856  fb23		       aa		      tax		; transfer it to X
    857  fb24		       e8		      inx		; and increase it by 1 for the human readable varation 1-4
    858  fb25		       86 80		      stx	Score	; save in Score so it shows on left side
    859  fb27		       a0 01		      ldy	#1	; default to showing 1 player variation
    860  fb29		       4a		      lsr		; D0 of Variation, # of players, now in Carry flag
    861  fb2a		       90 01		      bcc	Not2	; if Carry is clear, then show 1 player
    862  fb2c		       c8		      iny		; else set Y to 2 to show 2 players
    863  fb2d				   Not2
    864  fb2d		       66 a9		      ror	Players	; put Carry into D7 for BIT testing of # of players
    865  fb2f		       84 81		      sty	Score+1	; show the human readable # of players on right side
    866  fb31		       60		      rts
    867  fb32
    868  fb32				   NotSelect
    869  fb32		       a9 00		      lda	#0	; clears SelectDelay if SELECT not held
    870  fb34		       85 aa		      sta	SelectDelay
    871  fb36		       60		      rts
    872  fb37
    873  fb37
    874  fb37							;===============================================================================
    875  fb37							; NewGame
    876  fb37							; --------------
    877  fb37							; set starting position of the objects.  Players always start in a fixed
    878  fb37							; location.  Boxes will be randomly positioned.
    879  fb37							;===============================================================================
    880  fb37				   NewGame
    881  fb37							; set starting location of player0 and player1 objects
    882  fb37		       a9 0a		      lda	#10
    883  fb39		       85 89		      sta	ObjectX
    884  fb3b		       85 0c		      sta	REFP1	; bit D3 is on, so reflect player1
    885  fb3d		       a9 8e		      lda	#142
    886  fb3f		       85 8a		      sta	ObjectX+1
    887  fb41		       a9 63		      lda	#$63
    888  fb43		       85 8e		      sta	ObjectY
    889  fb45		       85 8f		      sta	ObjectY+1
    890  fb47		       85 0b		      sta	REFP0	; bit D3 is off, so don't reflect player0
    891  fb49							; reset timer
    892  fb49		       a9 ff		      lda	#%11111111
    893  fb4b		       85 9a		      sta	TimerPF
    894  fb4d		       85 9b		      sta	TimerPF+1
    895  fb4f		       85 9c		      sta	TimerPF+2
    896  fb51		       85 9d		      sta	TimerPF+3
    897  fb53		       85 9e		      sta	TimerPF+4
    898  fb55		       85 9f		      sta	TimerPF+5
    899  fb57
    900  fb57							; Randomly position the boxes for the new game.  Set X to 1 for a 1 player
    901  fb57							; game or 2 for a 2 player game so that the appropriate objects will be
    902  fb57							; randomly placed in the Arena.
    903  fb57		       a5 a8		      lda	Variation
    904  fb59		       29 01		      and	#1	; value of 0=1 player game, 1=2 player game
    905  fb5b		       aa		      tax		; transfer to X
    906  fb5c		       e8		      inx		; start with 1 for a 1 player game, or 2 for a 2 player game
    907  fb5d				   IPloop
    908  fb5d		       20 75 fb 	      jsr	RandomLocation	; randomly position object specified by X
    909  fb60		       e8		      inx		; increase X for next object
    910  fb61		       e0 05		      cpx	#5	; check if we hit 5
    911  fb63		       d0 f8		      bne	IPloop	; branch back if we haven't
    912  fb65
    913  fb65							; reset scores
    914  fb65		       a2 00		      ldx	#0
    915  fb67		       86 80		      stx	Score
    916  fb69		       24 a9		      bit	Players	; check # of players
    917  fb6b		       10 03		      bpl	BlankRightScore
    918  fb6d		       86 81		      stx	Score+1
    919  fb6f		       60		      rts
    920  fb70
    921  fb70				   BlankRightScore
    922  fb70		       a9 aa		      lda	#$AA	; AA defines a "space" character
    923  fb72		       85 81		      sta	Score+1
    924  fb74		       60		      rts
    925  fb75
    926  fb75
    927  fb75							;===============================================================================
    928  fb75							; RandomLocation
    929  fb75							; --------------
    930  fb75							; call with X to set to the object to randomly position:
    931  fb75							;   1 - player1
    932  fb75							;   2 - missile0
    933  fb75							;   3 - missile1
    934  fb75							;   4 - ball
    935  fb75							;
    936  fb75							; X position
    937  fb75							; ----------
    938  fb75							; There are 160 pixels across the screen.  There's also a border that takes up
    939  fb75							; 4 pixels on each side, plus the player objects span 8 pixels.  That gives us
    940  fb75							; a range of 160 - 4*2 - 8 = 144 possible positions to place an object.  Due to
    941  fb75							; due to the Arena border we need to shift that 4 to the right so the X position
    942  fb75							; can be anything from 4-148.
    943  fb75							;
    944  fb75							; Y position
    945  fb75							; ----------
    946  fb75							; Y position needs to be between 25-169
    947  fb75							;===============================================================================
    948  fb75				   RandomLocation
    949  fb75		       20 ab fb 	      jsr	Random	; get a random value between 0-255
    950  fb78		       29 7f		      and	#127	; limit range to 0-127
    951  fb7a		       85 88		      sta	Temp	; save it
    952  fb7c		       20 ab fb 	      jsr	Random	; get a random value between 0-255
    953  fb7f		       29 0f		      and	#15	; limit range to 0-15
    954  fb81		       18		      clc		; must clear carry for add
    955  fb82		       65 88		      adc	Temp	; add in random # from 0-127 for range of 0-142
    956  fb84		       69 05		      adc	#5	; add 5 for range of 5-147
    957  fb86		       95 89		      sta	ObjectX,x	; save the random X position
    958  fb88
    959  fb88		       20 ab fb 	      jsr	Random	; get a random value between 0-255
    960  fb8b		       29 7f		      and	#127	; limit range to 0-127
    961  fb8d		       85 88		      sta	Temp	; save it
    962  fb8f		       20 ab fb 	      jsr	Random	; get a random value between 0-255
    963  fb92		       29 0f		      and	#15	; limit range to 0-15
    964  fb94		       18		      clc		; must clear carry for add
    965  fb95		       65 88		      adc	Temp	; add in random # from 0-127 for range of 0-142
    966  fb97		       69 1a		      adc	#26	; add 26 for range of 26-168
    967  fb99		       95 8e		      sta	ObjectY,x	; save the random Y position
    968  fb9b		       60		      rts
    969  fb9c
    970  fb9c
    971  fb9c							;===============================================================================
    972  fb9c							; CollectBox
    973  fb9c							; --------------
    974  fb9c							; before calling, X and Y must set to the proper values:
    975  fb9c							;   X = object the box was drawn with so it can be repositioned
    976  fb9c							;   Y = player that collected box so their score can be increased
    977  fb9c							;
    978  fb9c							; Score is stored as Binary Coded Decimal, so we must set the Decimal flag
    979  fb9c							; before performing the addition.
    980  fb9c							;===============================================================================
    981  fb9c				   CollectBox
    982  fb9c		       f8		      SED		; SEt Decimal flag
    983  fb9d		       18		      clc		; CLear Carry bit
    984  fb9e		       a9 01		      lda	#1	; 1 point per box
    985  fba0		       79 80 00 	      adc	Score,y	; add to player's current score
    986  fba3		       99 80 00 	      sta	Score,y	; and save it
    987  fba6		       d8		      CLD		; CLear Decimal flag
    988  fba7		       20 75 fb 	      jsr	RandomLocation	; move box to new location
    989  fbaa		       60		      rts
    990  fbab
    991  fbab
    992  fbab							;===============================================================================
    993  fbab							; Random
    994  fbab							; --------------
    995  fbab							; There is no such thing as Random in computers.  To simulate a random number
    996  fbab							; it is common to use a Linear Feedback Shift Register, or LFSR for short.
    997  fbab							; We're going to use one that's known as a Galois LFSR:
    998  fbab							;	 http://en.wikipedia.org/wiki/Linear_feedback_shift_register#Galois_LFSRs
    999  fbab							;
   1000  fbab							; An LFSR will generate a seemingly random sequence of values, but the values
   1001  fbab							; will repeat after a while.  An 8 bit LFSR will repeat after 255 values.  A
   1002  fbab							; 16 bit LFSR will repeat after 65535 values.
   1003  fbab							;
   1004  fbab							; Fred Quimby, aka batari, wrote the routine we're using .  He posted it here:
   1005  fbab							;	 http://atariage.com/forums/topic/159268-random-numbers/?p=1958751
   1006  fbab							;
   1007  fbab							; Fred is also the create of the Harmony Cartridge, which is very handy for
   1008  fbab							; testing your program on a real Atari, as well as batari BASIC.
   1009  fbab							;   http://harmony.atariage.com/Site/Harmony.html
   1010  fbab							;   http://bataribasic.com
   1011  fbab							;
   1012  fbab							; In order to use this function you need to allocation a RAM variable called
   1013  fbab							; Rand8.  Doing just that and the code works as an 8 bit LFSR.  If you have
   1014  fbab							; some extra RAM, which isn't always feasible on the Atari, then allocating a
   1015  fbab							; second RAM variable called Rand16 will turn this into a 16 bit LFSR.
   1016  fbab							;===============================================================================
   1017  fbab				   Random
   1018  fbab		       a5 ab		      lda	Rand8
   1019  fbad		       4a		      lsr
   1020  fbae					      ifconst	Rand16
   1021  fbae		       26 ac		      rol	Rand16	; this command is only used if Rand16 has been defined
   1022  fbb0					      endif
   1023  fbb0		       90 02		      bcc	noeor
   1024  fbb2		       49 b4		      eor	#$B4
   1025  fbb4				   noeor
   1026  fbb4		       85 ab		      sta	Rand8
   1027  fbb6					      ifconst	Rand16
   1028  fbb6		       45 ac		      eor	Rand16	; this command is only used if Rand16 has been defined
   1029  fbb8					      endif
   1030  fbb8		       60		      rts
   1031  fbb9
   1032  fbb9
   1033  fbb9							;===============================================================================
   1034  fbb9							; free space check before DigitGfx
   1035  fbb9							;===============================================================================
   1036  fbb9
   1037  fbb9					      if	(* & $FF)
 ------ 71 bytes free before DigitGfx
   1038  fbb9					      echo	"------", [(>.+1)*256 - .]d, "bytes free before DigitGfx"
   1039  fc00		       00 00 00 00*	      align	256
   1040  fc00					      endif
   1041  fc00
   1042  fc00
   1043  fc00							;===============================================================================
   1044  fc00							; Digit Graphics
   1045  fc00							;===============================================================================
   1046  fc00					      align	256
   1047  fc00				   DigitGfx
   1048  fc00		       07		      .byte.b	%00000111
   1049  fc01		       05		      .byte.b	%00000101
   1050  fc02		       05		      .byte.b	%00000101
   1051  fc03		       05		      .byte.b	%00000101
   1052  fc04		       07		      .byte.b	%00000111
   1053  fc05
   1054  fc05		       11		      .byte.b	%00010001
   1055  fc06		       11		      .byte.b	%00010001
   1056  fc07		       11		      .byte.b	%00010001
   1057  fc08		       11		      .byte.b	%00010001
   1058  fc09		       11		      .byte.b	%00010001
   1059  fc0a
   1060  fc0a		       77		      .byte.b	%01110111
   1061  fc0b		       11		      .byte.b	%00010001
   1062  fc0c		       77		      .byte.b	%01110111
   1063  fc0d		       44		      .byte.b	%01000100
   1064  fc0e		       77		      .byte.b	%01110111
   1065  fc0f
   1066  fc0f		       77		      .byte.b	%01110111
   1067  fc10		       11		      .byte.b	%00010001
   1068  fc11		       33		      .byte.b	%00110011
   1069  fc12		       11		      .byte.b	%00010001
   1070  fc13		       77		      .byte.b	%01110111
   1071  fc14
   1072  fc14		       55		      .byte.b	%01010101
   1073  fc15		       55		      .byte.b	%01010101
   1074  fc16		       77		      .byte.b	%01110111
   1075  fc17		       11		      .byte.b	%00010001
   1076  fc18		       11		      .byte.b	%00010001
   1077  fc19
   1078  fc19		       77		      .byte.b	%01110111
   1079  fc1a		       44		      .byte.b	%01000100
   1080  fc1b		       77		      .byte.b	%01110111
   1081  fc1c		       11		      .byte.b	%00010001
   1082  fc1d		       77		      .byte.b	%01110111
   1083  fc1e
   1084  fc1e		       77		      .byte.b	%01110111
   1085  fc1f		       44		      .byte.b	%01000100
   1086  fc20		       77		      .byte.b	%01110111
   1087  fc21		       55		      .byte.b	%01010101
   1088  fc22		       77		      .byte.b	%01110111
   1089  fc23
   1090  fc23		       77		      .byte.b	%01110111
   1091  fc24		       11		      .byte.b	%00010001
   1092  fc25		       11		      .byte.b	%00010001
   1093  fc26		       11		      .byte.b	%00010001
   1094  fc27		       11		      .byte.b	%00010001
   1095  fc28
   1096  fc28		       77		      .byte.b	%01110111
   1097  fc29		       55		      .byte.b	%01010101
   1098  fc2a		       77		      .byte.b	%01110111
   1099  fc2b		       55		      .byte.b	%01010101
   1100  fc2c		       77		      .byte.b	%01110111
   1101  fc2d
   1102  fc2d		       77		      .byte.b	%01110111
   1103  fc2e		       55		      .byte.b	%01010101
   1104  fc2f		       77		      .byte.b	%01110111
   1105  fc30		       11		      .byte.b	%00010001
   1106  fc31		       77		      .byte.b	%01110111
   1107  fc32
   1108  fc32		       00		      .byte.b	%00000000	; used to blank out right score in 1 player games
   1109  fc33		       00		      .byte.b	%00000000
   1110  fc34		       00		      .byte.b	%00000000
   1111  fc35		       00		      .byte.b	%00000000
   1112  fc36		       00		      .byte.b	%00000000
   1113  fc37
   1114  fc37				   HumanGfx
   1115  fc37		       1c		      .byte.b	%00011100
   1116  fc38		       18		      .byte.b	%00011000
   1117  fc39		       18		      .byte.b	%00011000
   1118  fc3a		       18		      .byte.b	%00011000
   1119  fc3b		       5a		      .byte.b	%01011010
   1120  fc3c		       5a		      .byte.b	%01011010
   1121  fc3d		       3c		      .byte.b	%00111100
   1122  fc3e		       00		      .byte.b	%00000000
   1123  fc3f		       18		      .byte.b	%00011000
   1124  fc40		       18		      .byte.b	%00011000
   1125  fc40		       00 0a	   HUMAN_HEIGHT =	* - HumanGfx
   1126  fc41
   1127  fc41				   BoxGfx
   1128  fc41		       00		      .byte.b	%00000000
   1129  fc42		       00		      .byte.b	%00000000
   1130  fc43		       ff		      .byte.b	%11111111
   1131  fc44		       81		      .byte.b	%10000001
   1132  fc45		       81		      .byte.b	%10000001
   1133  fc46		       81		      .byte.b	%10000001
   1134  fc47		       81		      .byte.b	%10000001
   1135  fc48		       81		      .byte.b	%10000001
   1136  fc49		       81		      .byte.b	%10000001
   1137  fc4a		       ff		      .byte.b	%11111111
   1138  fc4b
   1139  fc4b				   ArenaPF0		; PF0 is drawn in reverse order, and only the upper nybble
   1140  fc4b		       f1		      .byte.b	%11110001	; Arena 1   lower nybble control playfield, set for REFLECT
   1141  fc4c		       10		      .byte.b	%00010000
   1142  fc4d		       10		      .byte.b	%00010000
   1143  fc4e		       10		      .byte.b	%00010000
   1144  fc4f		       10		      .byte.b	%00010000
   1145  fc50		       10		      .byte.b	%00010000
   1146  fc51		       10		      .byte.b	%00010000
   1147  fc52		       10		      .byte.b	%00010000
   1148  fc53		       10		      .byte.b	%00010000
   1149  fc54		       10		      .byte.b	%00010000
   1150  fc55		       10		      .byte.b	%00010000
   1151  fc56		       10		      .byte.b	%00010000
   1152  fc57		       10		      .byte.b	%00010000
   1153  fc58		       10		      .byte.b	%00010000
   1154  fc59		       10		      .byte.b	%00010000
   1155  fc5a		       10		      .byte.b	%00010000
   1156  fc5b		       10		      .byte.b	%00010000
   1157  fc5c		       10		      .byte.b	%00010000
   1158  fc5d		       10		      .byte.b	%00010000
   1159  fc5e		       10		      .byte.b	%00010000
   1160  fc5f		       10		      .byte.b	%00010000
   1161  fc60		       f0		      .byte.b	%11110000
   1162  fc61
   1163  fc61		       f4		      .byte.b	%11110100	; Arena 2 - lower nybble controls playfield, set for PRIORITY
   1164  fc62		       10		      .byte.b	%00010000
   1165  fc63		       10		      .byte.b	%00010000
   1166  fc64		       10		      .byte.b	%00010000
   1167  fc65		       10		      .byte.b	%00010000
   1168  fc66		       10		      .byte.b	%00010000
   1169  fc67		       10		      .byte.b	%00010000
   1170  fc68		       10		      .byte.b	%00010000
   1171  fc69		       10		      .byte.b	%00010000
   1172  fc6a		       10		      .byte.b	%00010000
   1173  fc6b		       10		      .byte.b	%00010000
   1174  fc6c		       00		      .byte.b	%00000000
   1175  fc6d		       00		      .byte.b	%00000000
   1176  fc6e		       00		      .byte.b	%00000000
   1177  fc6f		       c0		      .byte.b	%11000000
   1178  fc70		       00		      .byte.b	%00000000
   1179  fc71		       00		      .byte.b	%00000000
   1180  fc72		       00		      .byte.b	%00000000
   1181  fc73		       00		      .byte.b	%00000000
   1182  fc74		       00		      .byte.b	%00000000
   1183  fc75		       00		      .byte.b	%00000000
   1184  fc76		       f0		      .byte.b	%11110000
   1185  fc77
   1186  fc77
   1187  fc77				   ArenaPF1		; PF1 is drawn in expected order
   1188  fc77		       ff		      .byte.b	%11111111	; Arena 1
   1189  fc78		       00		      .byte.b	%00000000
   1190  fc79		       00		      .byte.b	%00000000
   1191  fc7a		       00		      .byte.b	%00000000
   1192  fc7b		       1c		      .byte.b	%00011100
   1193  fc7c		       00		      .byte.b	%00000000
   1194  fc7d		       00		      .byte.b	%00000000
   1195  fc7e		       c0		      .byte.b	%11000000
   1196  fc7f		       40		      .byte.b	%01000000
   1197  fc80		       40		      .byte.b	%01000000
   1198  fc81		       41		      .byte.b	%01000001
   1199  fc82		       41		      .byte.b	%01000001
   1200  fc83		       40		      .byte.b	%01000000
   1201  fc84		       40		      .byte.b	%01000000
   1202  fc85		       c0		      .byte.b	%11000000
   1203  fc86		       00		      .byte.b	%00000000
   1204  fc87		       00		      .byte.b	%00000000
   1205  fc88		       1c		      .byte.b	%00011100
   1206  fc89		       00		      .byte.b	%00000000
   1207  fc8a		       00		      .byte.b	%00000000
   1208  fc8b		       00		      .byte.b	%00000000
   1209  fc8c		       ff		      .byte.b	%11111111
   1210  fc8d
   1211  fc8d		       00		      .byte.b	%00000000	; Arena 2
   1212  fc8e		       00		      .byte.b	%00000000
   1213  fc8f		       00		      .byte.b	%00000000
   1214  fc90		       38		      .byte.b	%00111000
   1215  fc91		       00		      .byte.b	%00000000
   1216  fc92		       00		      .byte.b	%00000000
   1217  fc93		       00		      .byte.b	%00000000
   1218  fc94		       00		      .byte.b	%00000000
   1219  fc95		       00		      .byte.b	%00000000
   1220  fc96		       00		      .byte.b	%00000000
   1221  fc97		       0c		      .byte.b	%00001100
   1222  fc98		       18		      .byte.b	%00011000
   1223  fc99		       30		      .byte.b	%00110000
   1224  fc9a		       60		      .byte.b	%01100000
   1225  fc9b		       c0		      .byte.b	%11000000
   1226  fc9c		       00		      .byte.b	%00000000
   1227  fc9d		       00		      .byte.b	%00000000
   1228  fc9e		       00		      .byte.b	%00000000
   1229  fc9f		       38		      .byte.b	%00111000
   1230  fca0		       00		      .byte.b	%00000000
   1231  fca1		       00		      .byte.b	%00000000
   1232  fca2		       00		      .byte.b	%00000000
   1233  fca3
   1234  fca3
   1235  fca3				   ArenaPF2		; PF2 is drawn in reverse order
   1236  fca3		       ff		      .byte.b	%11111111	; Arena 1
   1237  fca4		       80		      .byte.b	%10000000
   1238  fca5		       00		      .byte.b	%00000000
   1239  fca6		       00		      .byte.b	%00000000
   1240  fca7		       00		      .byte.b	%00000000
   1241  fca8		       00		      .byte.b	%00000000
   1242  fca9		       1c		      .byte.b	%00011100
   1243  fcaa		       04		      .byte.b	%00000100
   1244  fcab		       00		      .byte.b	%00000000
   1245  fcac		       00		      .byte.b	%00000000
   1246  fcad		       00		      .byte.b	%00000000
   1247  fcae		       00		      .byte.b	%00000000
   1248  fcaf		       00		      .byte.b	%00000000
   1249  fcb0		       00		      .byte.b	%00000000
   1250  fcb1		       04		      .byte.b	%00000100
   1251  fcb2		       1c		      .byte.b	%00011100
   1252  fcb3		       00		      .byte.b	%00000000
   1253  fcb4		       00		      .byte.b	%00000000
   1254  fcb5		       00		      .byte.b	%00000000
   1255  fcb6		       00		      .byte.b	%00000000
   1256  fcb7		       80		      .byte.b	%10000000
   1257  fcb8		       ff		      .byte.b	%11111111
   1258  fcb9
   1259  fcb9		       ff		      .byte.b	%11111111	; Arena 2
   1260  fcba		       00		      .byte.b	%00000000
   1261  fcbb		       04		      .byte.b	%00000100
   1262  fcbc		       04		      .byte.b	%00000100
   1263  fcbd		       1c		      .byte.b	%00011100
   1264  fcbe		       00		      .byte.b	%00000000
   1265  fcbf		       00		      .byte.b	%00000000
   1266  fcc0		       00		      .byte.b	%00000000
   1267  fcc1		       00		      .byte.b	%00000000
   1268  fcc2		       00		      .byte.b	%00000000
   1269  fcc3		       00		      .byte.b	%00000000
   1270  fcc4		       00		      .byte.b	%00000000
   1271  fcc5		       00		      .byte.b	%00000000
   1272  fcc6		       00		      .byte.b	%00000000
   1273  fcc7		       00		      .byte.b	%00000000
   1274  fcc8		       00		      .byte.b	%00000000
   1275  fcc9		       00		      .byte.b	%00000000
   1276  fcca		       1c		      .byte.b	%00011100
   1277  fccb		       04		      .byte.b	%00000100
   1278  fccc		       04		      .byte.b	%00000100
   1279  fccd		       00		      .byte.b	%00000000
   1280  fcce		       ff		      .byte.b	%11111111
   1281  fccf
   1282  fccf
   1283  fccf							;===============================================================================
   1284  fccf							; free space check before End of Cartridge
   1285  fccf							;===============================================================================
   1286  fccf
   1287  fccf					      if	(* & $FF)
 ------ 811 bytes free before End of Cartridge
   1288  fccf					      echo	"------", [$FFFA - *]d, "bytes free before End of Cartridge"
   1289  fd00		       00 00 00 00*	      align	256
   1290  fd00					      endif
   1291  fd00
   1292  fd00							;===============================================================================
   1293  fd00							; Define End of Cartridge
   1294  fd00							;===============================================================================
   1295  fffa					      ORG	$FFFA	; set address to 6507 Interrupt Vectors
   1296  fffa		       13 f8		      .WORD.w	InitSystem	; NMI
   1297  fffc		       13 f8		      .WORD.w	InitSystem	; RESET
   1298  fffe		       13 f8		      .WORD.w	InitSystem	; IRQ
